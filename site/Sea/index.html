<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

	<script src="./src/three.js"></script>
	<script src="./src/OrbitControls.js"></script>
	<script src="./src/RGBELoader.js"></script>
	<script src="./src/EffectComposer.js"></script>
	<script src="./src/RenderPass.js"></script>
	<script src="src/CopyShader.js"></script>
	<script src="src/ShaderPass.js"></script>
	<script src="./src/UnrealBloomPass.js"></script>
	<script src="./src/LuminosityHighPassShader.js"></script>
	<script src="./src/Water.js"></script>

	<style>
		html,
		body {
			height: 100%;
			width: 100%;
			overflow: hidden;
			background-color: transparent;
			position: absolute;
			margin: 0 !important;
		}

		canvas {
			position: absolute;
			cursor: move;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			border: none;
			outline: none;
		}
	</style>
</head>

<body>

	<script type=text/javascript>

// Scene Camera & Renderer

	const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true});
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor( 0x000000, 0 );
	document.body.appendChild( renderer.domElement );
	
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.outputEncoding = THREE.LinearEncoding;
	
	scene = new THREE.Scene();
	
	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.5, 1000 );  
	
	camera.position.set( -1, 25, -1 );
	scene.position.y -= 0.5; 

	const pmremGenerator = new THREE.PMREMGenerator( renderer );
    pmremGenerator.compileEquirectangularShader();

	const rgbl = new THREE.RGBELoader();
	rgbl.setDataType( THREE.UnsignedByteType )
	rgbl.setPath( './src/' )
	rgbl.load( 'map.hdr', function ( texture ) {

	const envMap = pmremGenerator.fromEquirectangular( texture ).texture;
	scene.environment = envMap;
	scene.background = envMap;
	
 })
		  	
// Objects

const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );

water = new THREE.Water(
	waterGeometry,
	{
		textureWidth: 512,
		textureHeight: 512,
		waterNormals: new THREE.TextureLoader().load( './src/textures/waternormals.jpg', function ( texture ) {

			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

		} ),
		alpha: 1.0,
		sunDirection: new THREE.Vector3(),
		sunColor: 0xffffff,
		waterColor: 0x001e0f,
		distortionScale: 3.7,
		fog: scene.fog !== undefined
	}
);

water.rotation.x = - Math.PI / 2;

scene.add( water );
	
// Controls		
		 
	const controls = new THREE.OrbitControls( camera, renderer.domElement );
		 
	controls.maxPolarAngle = Math.PI / 2;
	controls.minPolarAngle = Math.PI / 2;
	controls.enableDamping = true;
	controls.enablePan = true;
	controls.dampingFactor = 0.1;
	controls.autoRotate = false;
	controls.autoRotateSpeed = 1;
	controls.maxDistance = 4;
	controls.minDistance = 3;
	controls.zoomSpeed = 0.5;
	controls.rotateSpeed = 0.5;
	controls.target.set(-1, 4, -1);

// PostProcessing

	const width = window.innerWidth;
	const height = window.innerHeight;

	const composer = new THREE.EffectComposer( renderer );
	composer.setSize(window.innerWidth, window.innerHeight);
	
	const renderPass = new THREE.RenderPass( scene, camera );
	composer.addPass( renderPass );

// BLOOM		

	const params = {
	exposure: 1,
	bloomStrength: 0.25,
	bloomThreshold: 0.99,
	bloomRadius: 0
	};

	const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
	bloomPass.threshold = params.bloomThreshold;
	bloomPass.strength = params.bloomStrength;
	bloomPass.radius = params.bloomRadius;

	composer.addPass( bloomPass );
		
// Animation & render

	function animate() {

	const time = performance.now() * 0.001;
	water.material.uniforms[ 'time' ].value += 1.0 / 200.0;

	//renderer.render(scene, camera);
	composer.render(scene, camera);

	//renderer.setPixelRatio(window.devicePixelRatio);
	composer.setPixelRatio(window.devicePixelRatio);

	requestAnimationFrame(animate);

	controls.update();

	if (resizeRendererToDisplaySize(renderer, composer )) {
	const canvas = renderer.domElement;
	camera.aspect = canvas.clientWidth / canvas.clientHeight;
	camera.updateProjectionMatrix();
	}

	}

	animate();

	function resizeRendererToDisplaySize(renderer, composer ) {
	const canvas = renderer.domElement;
	var width = window.innerWidth;
	var height = window.innerHeight;
	var canvasPixelWidth = canvas.width / window.devicePixelRatio;
	var canvasPixelHeight = canvas.height / window.devicePixelRatio;

	const needResize = canvasPixelWidth !== width || canvasPixelHeight !== height;
	if (needResize) {

	renderer.setSize(width, height, true);
	}
	return needResize;
	}
	</script>

</body>

</html